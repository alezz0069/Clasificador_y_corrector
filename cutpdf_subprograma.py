# -*- coding: utf-8 -*-
"""CutPDF subprograma.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aH0goGbOEHlC5aB_DVqa9syPTkwVybVz
"""

from google.colab.patches import cv2_imshow

#pip install PyMuPDF pdf2image

#import shutil

#shutil.rmtree('/content/output')

import fitz  # PyMuPDF
import cv2
import numpy as np
import pandas as pd
import math
import os
from PIL import Image
import io


def process_image(input_image_path, output_dir):
    # Ensure the output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Load the input image
    img = cv2.imread(input_image_path)
    img_original = cv2.imread(input_image_path)

    # Calculate the number of pixels to trim from each side
    trim_pixels = int(0.19685 * 300)  # approximately 59 pixels for 5mm at 300 DPI

    # Trim the image
    img_original = img[trim_pixels:-trim_pixels, trim_pixels:-trim_pixels]

    gray = img
    edges = cv2.Canny(gray, 30, 150, apertureSize=3)

    # Dilate the edges to make the lines thicker
    kernel = np.ones((3, 3), np.uint8)
    iterations = 3  # Increase the number of iterations for thicker lines
    dilated_edges = cv2.dilate(edges, kernel, iterations=iterations)

    # Save the enhanced lines image
    enhanced_lines_path = os.path.join(output_dir, 'enhance_lines.jpg')
    cv2.imwrite(enhanced_lines_path, dilated_edges)

    # Load the enhanced lines image
    img = cv2.imread(os.path.join(output_dir, 'enhance_lines.jpg'))

    # Calculate the number of pixels to trim from each side
    trim_pixels = int(0.19685 * 300)  # approximately 59 pixels for 5mm at 300 DPI

    # Trim the image
    img = img[trim_pixels:-trim_pixels, trim_pixels:-trim_pixels]

    # Convert image to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Apply Gaussian Blur to reduce noise
    blur = cv2.GaussianBlur(gray, (5, 5), 0)

    # Apply Canny edge detection
    edges = cv2.Canny(blur, 50, 150, apertureSize=5)

    # Dilate the edges to make the lines thicker
    kernel = np.ones((3, 3), np.uint8)
    iterations = 3  # Increase the number of iterations for thicker lines
    edges = cv2.dilate(edges, kernel, iterations=iterations)

    # Use Hough Line Transform to detect lines and draw them
    lines = cv2.HoughLinesP(edges, 0.5, np.pi / 360, 20, None, 5, 10)
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0]
            angle = abs(math.degrees(math.atan2(y2 - y1, x2 - x1)))
            line_length = math.hypot(x2 - x1, y2 - y1)
            if (angle < 0.05 or abs(180 - angle) < 0.05 or abs(angle - 90) < 0.05) and line_length > 100:
                cv2.line(img, (x1, y1), (x2, y2), (0, 255, 255), 2)

    # Save the image with lines detected
    result_pre_area_path = os.path.join(output_dir, 'result_pre_area.jpg')
    cv2.imwrite(result_pre_area_path, img)

    # Find contours in the image
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filter out small contours based on area
    min_contour_area = 500  # this value is just an example, you might need to adjust it
    contours = [cnt for cnt in contours if cv2.contourArea(cnt) > min_contour_area]

    # Sort the contours by area in descending order
    contours = sorted(contours, key=cv2.contourArea, reverse=True)
    cv2.drawContours(img, [contours[0]], -1, (0, 0, 139), 2)  # draw in dark red

    # Save the image with the largest contour drawn
    result_pre_area2_path = os.path.join(output_dir, 'result_pre_area2.jpg')
    cv2.imwrite(result_pre_area2_path, img)

    # Approximate the largest contour with a polygon
    epsilon = 0.02 * cv2.arcLength(contours[0], True)
    approx = cv2.approxPolyDP(contours[0], epsilon, True)

    # Draw the vertices of the polygon
    for vertex in approx:
        cv2.circle(img, tuple(vertex[0]), 5, (0, 0, 255), -1)

    # Save the image with vertices marked
    result_dots_path = os.path.join(output_dir, 'result_dots.png')
    cv2.imwrite(result_dots_path, img)

    # Create and save a DataFrame with the vertex locations
    vertex_data = {'x': approx[:, 0, 0], 'y': approx[:, 0, 1]}
    vertex_df = pd.DataFrame(vertex_data)
    vertices_csv_path = os.path.join(output_dir, 'vertices.csv')
    vertex_df.to_csv(vertices_csv_path, index=False)

    # Create a blank image to draw the polygon
    polygon_img = np.zeros((img.shape[0], img.shape[1], 3), np.uint8)
    scaled_vertices = approx[:, 0, :].astype(int)
    cv2.fillPoly(polygon_img, [scaled_vertices], (0, 0, 255))

    # Save the image with the polygon drawn
    polygon_drawn_path = os.path.join(output_dir, 'polygon_drawn.jpg')
    cv2.imwrite(polygon_drawn_path, polygon_img)

    # Create a mask and combine it with the original image
    mask = np.zeros_like(img_original)
    cv2.fillPoly(mask, [scaled_vertices], (255, 255, 255))
    result_img = cv2.addWeighted(img_original, 1, mask, 1, 0)
    result_img = cv2.cvtColor(result_img, cv2.COLOR_BGR2RGB)

    # Save the resulting image
    cropped_image_path = os.path.join(output_dir, 'cropped_image.jpg')
    cv2.imwrite(cropped_image_path, result_img)

    # Fill the inside of the polygon with white and keep the rest of the image
    white_img = np.ones_like(img_original) * 255
    white_img = cv2.bitwise_and(white_img, 255 - mask)
    img = cv2.bitwise_or(img_original, white_img)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    # Save the filled image
    filled_image_path = os.path.join(output_dir, 'filled_image.jpg')
    cv2.imwrite(filled_image_path, img)

    # Return paths to the saved images
    return {
        'enhanced_lines': enhanced_lines_path,
        'result_pre_area': result_pre_area_path,
        'result_pre_area2': result_pre_area2_path,
        'result_dots': result_dots_path,
        'polygon_drawn': polygon_drawn_path,
        'cropped_image': cropped_image_path,
        'filled_image': filled_image_path,
        'vertices_csv': vertices_csv_path
    }



# Function to convert PDF to PNG
def pdf_to_png(pdf_path, output_folder):
    # Open the PDF file
    pdf = fitz.open(pdf_path)

    # Ensure the output directory exists
    os.makedirs(output_folder, exist_ok=True)

    # Initialize a list to store the output image paths
    output_paths = []

    # Iterate over each page
    for page_number in range(len(pdf)):
        # Get the page
        page = pdf[page_number]

        # Render page to an image (pixmap)
        pix = page.get_pixmap(dpi=300)  # Specify the DPI for high-quality rendering

        # Convert the pixmap to a PIL image
        img = Image.open(io.BytesIO(pix.tobytes()))

        # Construct the output folder name with PDF name and page number
        folder_name = os.path.splitext(os.path.basename(pdf_path))[0]
        output_folder_page = os.path.join(output_folder, folder_name, f'page_{page_number + 1}')
        os.makedirs(output_folder_page, exist_ok=True)

        # Construct the output filename
        output_file = os.path.join(output_folder_page, 'image.png')

        # Save the PIL image as a PNG
        img.save(output_file, "PNG")

        # Append the output path to the list
        output_paths.append(output_file)

        # Process the image for each page
        process_image(output_file, output_folder_page)

    # Close the PDF after conversion
    pdf.close()

    # Return the list of output paths
    return output_paths

    

def main(pdf_folder, output_folder):
    # List all PDF files in the folder
    pdf_files = [f for f in os.listdir(pdf_folder) if f.endswith('.pdf')]

    # Process each PDF file in the folder
    for pdf_file in pdf_files:
        pdf_path = os.path.join(pdf_folder, pdf_file)
        # Create a subfolder for each PDF to store results
        pdf_output_folder = os.path.join(output_folder, os.path.splitext(pdf_file)[0])
        os.makedirs(pdf_output_folder, exist_ok=True)
        # Convert the PDF to PNG
        output_image_paths = pdf_to_png(pdf_path, pdf_output_folder)
        # Print the paths of the saved images for each PDF
        print(f"Processed PDF: {pdf_file}")
        for image_path in output_image_paths:
            print(f"  {image_path}")

if __name__ == "__main__":
    # Specify the PDF folder containing multiple PDFs
    pdf_folder = '/content/'  # Replace with your actual folder path
    output_folder = '/content/output/'  # Replace with your desired output path

    main(pdf_folder, output_folder)

#import os
#
#def print_directory_tree(root_dir):
#    for root, dirs, files in os.walk(root_dir):
#        level = root.replace(root_dir, '').count(os.sep)
#        indent = ' ' * 4 * (level)
#        print(f"{indent}[{os.path.basename(root)}/]")
#        subindent = ' ' * 4 * (level + 1)
#        for file in files:
#            print(f"{subindent}{file}")
#
## Replace 'your_root_directory' with the path to the directory you want to visualize
#root_directory = '/content/output/'  # Change this to your desired root directory
#
#print_directory_tree(root_directory)