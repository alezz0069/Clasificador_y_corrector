# -*- coding: utf-8 -*-
"""Clasificador.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WI1AzGHT2gPbl-4qAtanPofuh1--3yCD
"""

import subprocess

# Install dependencies
subprocess.run(['pip', 'install', '-r', 'requirements.txt'])

# Continue with your existing code

import fitz  # PyMuPDF
import pandas as pd
import csv
import os
from PIL import Image
import io
from google.colab.patches import cv2_imshow
import cv2
import numpy as np
import math
import os
import numpy as np
from doctr.io import DocumentFile
from doctr.models import ocr_predictor
from PIL import Image, ImageDraw
import pandas as pd
from typing import Any, List, Tuple



def get_pdf_size(path, tolerance=0.10):
    # Open the PDF file
    pdf = fitz.open(path)
    # Get the dimensions of the first page
    page = pdf[0]
    width, height = page.rect.width, page.rect.height
    # Close the PDF file
    pdf.close()

    # Define the sizes in points with a tolerance
    sizes = {
        'A0': (2384, 3370),
        'A1': (1684, 2384),
        'A2': (1191, 1684),
        'A3': (842, 1191),
        'A4': (595, 842),
    }

    # Compare the dimensions to determine the size within the tolerance
    for size, dims in sizes.items():
        if (abs(width - dims[0]) <= dims[0] * tolerance and abs(height - dims[1]) <= dims[1] * tolerance) or \
           (abs(width - dims[1]) <= dims[1] * tolerance and abs(height - dims[0]) <= dims[0] * tolerance):
            return size, width, height
    return None, width, height

def classify_document(pdf_path, csv_path):
    # Check if it's a drawing
    pdf_size, width, height = get_pdf_size(pdf_path)

    if pdf_size == 'A4':
        return f"This is a PDF-Document, Size: {pdf_size}, Width: {width} points, Height: {height} points."
    else:
        # Run the subprogram if it's a drawing
        subprocess.run(['python', 'cutpdf_subprograma.py'])
        #result = subprocess.run(['python', 'cutpdf_subprograma.py'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        #print("Subprocess Output:", result.stdout)

        subprocess.run(['python', 'passtheocr.py'])
        result = subprocess.run(['python', 'passtheocr.py'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        #print("Subprocess Output:", result.stdout)
        #print("Subprocess Exit Code:", result.returncode)
        # After running the subprogram, read and check the CSV
        df = pd.read_csv(csv_path)
        keywords = [
            'electrical', 'electric', 'wiring', 'wiring diagram',
            'eléctrico', 'eléctrica', 'cableado',
            'circuito', 'circuit'
        ]
        is_electrical_diagram = any(df['text'].str.contains('|'.join(keywords), case=False, na=False))

        # Additional classification for PDF-P&ID
        pid_keywords = ['P&ID', 'PID']  # Add more P&ID-related keywords here
        is_pid_document = any(df['text'].str.contains('|'.join(pid_keywords), case=False, na=False))

        # Additional classification for PDF-Drawing Ensamble
        drawing_keywords = ['VISTA ISOMÉTRICA', 'VISTA ISOMÉTRICO', 'ISOMÉTRICO', 'ISOMÉTRICA']  # Add more drawing-related keywords here
        is_drawing_ensamble = any(df['text'].str.contains('|'.join(drawing_keywords), case=False, na=False))

        if is_pid_document:
            document_type = 'PDF-P&ID'
        elif is_electrical_diagram:
            document_type = 'PDF-Electrical Diagram'
        elif is_drawing_ensamble:
            document_type = 'PDF-Drawing Ensamble'
        else:
            document_type = 'PDF-Drawing non-electrical'
        # Extract the PDF name from the pdf_path
        pdf_name = os.path.basename(pdf_path)

        return f"This is a {document_type}-{pdf_name}, Size: {pdf_size}, Width: {width} points, Height: {height} points."

pdf_path = '/content/2.pdf'
csv_path = '/content/final_output.csv'

result_message = classify_document(pdf_path, csv_path)
print(result_message)